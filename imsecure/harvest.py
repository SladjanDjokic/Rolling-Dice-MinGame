#!/usr/bin/env python3

import argparse
import os
from imsecure.image_secure import ImageSecure
import sys

#like print to stderr
def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)
'''
This builds a container of contigous keys generated by PIN.  The
puprose to create a sample large enough for staistical tests to
get valid results
'''
def key_stream(tocheck, pins, mode='lowbit', keysize=256, ncount=1,
        ratio=100, verbose=False):
    keystream = []
    if not isinstance(tocheck, (list, tuple)):
        tocheck = [tocheck]
    for filename in tocheck:
        for pin in pins:
            if int(verbose) > 0:
                print(f'\nprocessing ***{filename}*** with pin= {pin}')
            secure = ImageSecure(filename=filename, pin=pin, keysize=keysize,
                mode=mode, ncount=ncount, ratio=ratio, compress=False, verbose=verbose)
            key = secure.harvest(pin=pin)
            eprint(secure.sanity)
            keystream.extend(key)
    return keystream


'''
Save key data for RNG tests.
Since this is for internal testing, we create a name that reflects
source file it was generated from
'''
def save_to_bin(data, basename, type):
    path = f'{os.path.splitext(basename)[0]}_{type}.bin'
    print(f'target file: {path}')
    with open(path, "wb") as newfile:
        newfile.write(bytes(data))
'''
python harvest.py -v 1 -keysize 4096  -m lowbit  -pinfile testpins.txt IMG_0216.JPG
'''
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='harvest extended key data for statiscal tests')
    parser.add_argument('files', nargs='+', help="jpg/png files you wish to harvest")

    parser.add_argument('-pinfile', nargs='?', action='store', default="",
                    dest='pinfile',
                    help="file of pins to use")

    parser.add_argument('-pin', default="092291", type=str,
                    dest='pin',
                    help='starting 6 digit pin, greater than 1000')

    parser.add_argument('-mode', default="lowbit", type=str,
                    dest='mode', choices=ImageSecure.modes(),
                    help='mode for harvesting key')

    parser.add_argument('-output', default="", type=str,
                    dest='output',
                    help='output file for cumulative key data')

    parser.add_argument('-keysize', default=256, type=int,
                    dest='keysize',
                    help='keysize in bits (multiple of 8): ')

    parser.add_argument('-count', default=256, type=int,
                    dest='count',
                    help='count of pins used: ')

    parser.add_argument('-step', default=1, type=int,
                    dest='step',
                    help='step for pins: ')

    parser.add_argument('-v', dest='verbose',
                    default=1,
                    help='verbose details')

    parser.add_argument('-ratio', default=100, type=int,
                    dest='ratio',
                    help='ratio of pixels required per key bit')

    parser.add_argument('-ncount', default=1, type=int,
                    dest='ncount',
                    help='number of pixels/colors in multi modes: ')



    args = parser.parse_args()

    print(f'{args}')
    print(f'checking files {args.files}')
    savename = args.files[0] if args.output == "" else args.output

    if args.pinfile == "":
        pins = [pin for pin in range(args.pin, args.pin+args.count, args.step)]
    else:
        pins = []
        with open(args.pinfile) as fp:
            for cnt, line in enumerate(fp):
               result = [x.strip() for x in filter(None, line.split(','))]
               #print(f"Line {cnt}: {line} {result}")
               pins.extend(result)
            print(f'checking pins {pins}')

    data = key_stream(args.files, pins, mode=args.mode, ncount=args.ncount, keysize=args.keysize,
        ratio=args.ratio, verbose=args.verbose)
    save_to_bin(data, savename, f'{args.mode}')
